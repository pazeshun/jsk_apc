(require "package://jsk_arc2017_baxter/euslisp/lib/pick-kiva-pod-interface.l")

(setq *bin* :c)

(defun demo-init ()
  (jsk_arc2017_baxter::pick-kiva-pod-init :ctype :default-controller :moveit nil)
  (send *baxter* :arc-reset-pose)
  (objects (list *baxter*))
  (send *ti* :recognize-bin-boxes :stamp (ros::time-now))
  (send *ti* :recognize-tote-boxes :stamp (ros::time-now))
  (send *irtviewer* :change-background #f(1 1 1))
  t)

(defun make-bin-and-object
  (&key (object-size (list 50 50 50)))
  (if (eq *bin* :tote)
    (progn
      (setq bin-cube (gethash :rarm (send *ti* :get-val 'tote-cubes-)))
      (setq wall-thickness 30)
      (setq bin-wall (make-cube
                       (+ (x-of-cube bin-cube) (* wall-thickness 2))
                       (+ (y-of-cube bin-cube) (* wall-thickness 2))
                       (z-of-cube bin-cube)))
      (setq bin-floor (make-cube
                        (+ (x-of-cube bin-cube) (* wall-thickness 2))
                        (+ (y-of-cube bin-cube) (* wall-thickness 2))
                        wall-thickness))
      (send bin-wall :move-to bin-cube :world)
      (send bin-floor :move-to bin-cube :world)
      (send bin-floor :locate
            (float-vector
              0 0 (/ (+ (z-of-cube bin-cube) wall-thickness) -2))
            :local)
      (setq bin-wall (body- bin-wall bin-cube))
      (send bin-wall :set-color #f(1 0.3 0) 0.3)
      (send bin-floor :set-color #f(1 0.3 0) 1)
      )
    (progn
      (setq bin-cube (gethash *bin* (send *ti* :get-val 'bin-cubes-)))
      (setq wall-thickness 30)
      (setq bin-wall (make-cube
                       (+ (x-of-cube bin-cube) wall-thickness)
                       (+ (y-of-cube bin-cube) (* wall-thickness 2))
                       (+ (z-of-cube bin-cube) wall-thickness)))
      (setq bin-floor (make-cube
                        wall-thickness
                        (+ (y-of-cube bin-cube) (* wall-thickness 2))
                        (+ (z-of-cube bin-cube) wall-thickness)))
      (send bin-wall :move-to bin-cube :world)
      (send bin-floor :move-to bin-cube :world)
      (send bin-wall :locate (float-vector (/ wall-thickness 2) 0 (/ wall-thickness -2)) :local)
      (send bin-floor :locate
            (float-vector
              (/ (+ (x-of-cube bin-cube) wall-thickness) -2) 0 (/ wall-thickness -2))
            :local)
      (setq bin-wall (body- bin-wall bin-cube))
      (send bin-wall :set-color #f(1 0.3 0) 0.3)
      (send bin-floor :set-color #f(1 0.3 0) 1)
      )
    )
  (if (= (length object-size) 3)
    (setq object (apply #'make-cube object-size))
    (setq object (apply #'make-cylinder object-size)))
  (send object :set-color #f(0 0 1))
  (send object :move-to bin-cube :world)
  (objects (list object *baxter* bin-floor bin-wall))
  )

(defun locate-object
  (&key (object-offset #f(0 0 0)) (on-floor nil))
  (send object :move-to bin-cube :world)
  (send object :locate
        (v+ (float-vector 0 0 (/ (z-of-cube bin-cube) 2)) object-offset)
        :local)
  (if on-floor
    (if (eq *bin* :tote)
      (send object :locate
            (float-vector
              0 0
              (- (/ (if (z-of-cube object) (z-of-cube object) 0) 2)
                 (z-of-cube bin-cube)
                 (elt object-offset 2)))
            :local)
      (send object :locate
            (float-vector
              (- (/ (if (x-of-cube object) (x-of-cube object) 0) 2)
                 (/ (x-of-cube bin-cube) 2)
                 (elt object-offset 0))
              0 0)
            :local)
      )
    )
  (send *irtviewer* :draw-objects)
  )

(defun display-hand-poses
  (&key (sign_z 0) (sign_y 0) (style :cylindrical) (closep nil)
        object-size object-offset
        (robot *baxter*))
  (if style
    (send robot :hand-grasp-pre-pose :rarm style)
    (progn
      (send robot :hand-grasp-pre-pose :rarm :opposed)
      (setq style :opposed)
      (setq closep t)
      )
    )
  (if closep
    (progn
      (if (null object-size) (setq object-size (list 60 60 60)))
      ;; (list 60 60 80) is recommended when sign_y = -1
      (if (null object-offset) (setq object-offset #f(0 0 -200)))
      (unless (and (= (x-of-cube object) (elt object-size 0))
                   (= (y-of-cube object) (elt object-size 1))
                   (= (z-of-cube object) (elt object-size 2)))
        (make-bin-and-object :object-size object-size)
        )
      (locate-object :object-offset object-offset :on-floor t)
      (setq target-coords (send object :copy-worldcoords))
      (send target-coords :rotate (* (deg2rad 90) sign_z) :z :local)
      (send target-coords :rotate (* (deg2rad 90) sign_y) :y :local)
      (send robot :slide-gripper :rarm 124 :relative nil)
      (send robot :hand-grasp-pose :rarm style :angle 90)
      (if (= sign_y 0)
        (progn
          (send target-coords :translate #f(-30 0 0) :local)
          (send robot :rotate-gripper :rarm 0 :relative nil)
          )
        (send robot :rotate-gripper :rarm 90 :relative nil)
        )
      (send robot :rarm :inverse-kinematics target-coords)
      (send robot :rarm :move-end-pos #f(0 0 35) :local)
      (send *irtviewer* :draw-objects)
      (unless (y-or-n-p "continue?") (return-from display-hand-poses))
      (if (= sign_y 0)
        (send robot :hand-grasp-pose :rarm style :angle 25)
        (progn
          (send (send robot :rarm :end-coords) :assoc object)
          (send robot :rarm :move-end-pos #f(-160 0 0) :local)
          (send (send robot :rarm :end-coords) :dissoc object)
          )
        )
      (send *irtviewer* :draw-objects)
      )
    (progn
      (if (null object-size) (setq object-size (list 80 80 80)))
      (if (null object-offset) (setq object-offset #f(0 0 -90)))
      (unless (and (= (x-of-cube object) (elt object-size 0))
                   (= (y-of-cube object) (elt object-size 1))
                   (= (z-of-cube object) (elt object-size 2)))
        (make-bin-and-object :object-size object-size)
        )
      (locate-object :object-offset object-offset :on-floor t)
      (setq target-coords (send object :copy-worldcoords))
      (send target-coords :rotate (* (deg2rad 90) sign_z) :z :local)
      (send target-coords :rotate (* (deg2rad 90) sign_y) :y :local)
      (if (= sign_y 0)
        (send target-coords :translate #f(-30 0 0) :local)
        (send target-coords :rotate (deg2rad 180) :z :local))
      (if (= sign_y 0)
        (progn
          (send robot :slide-gripper :rarm (if (eq *bin* :tote) 124 50) :relative nil)
          (send robot :rotate-gripper :rarm 0 :relative nil)
          )
        (progn
          (send robot :slide-gripper :rarm 100 :relative nil)
          (send robot :rotate-gripper :rarm -90 :relative nil)
          )
        )
      (send robot :rarm :inverse-kinematics target-coords)
      (send robot :rarm :move-end-pos #f(0 0 45) :local)
      (send *irtviewer* :draw-objects)
      (unless (y-or-n-p "continue?") (return-from display-hand-poses))
      (send (send robot :rarm :end-coords) :assoc object)
      (let ((draw-l (if (eq *bin* :tote) (+ (z-of-cube bin-cube) 30) 200)))
        (if (= sign_y 0)
          (send robot :rarm :move-end-pos (float-vector 0 0 draw-l) :local)
          (send robot :rarm :move-end-pos (float-vector draw-l 0 0) :local)
          )
        )
      (if (eq style :cylindrical)
        (send robot :hand-grasp-pose :rarm style :angle 37)
        (progn
          (send robot :hand-grasp-pose :rarm style :angle 70)
          (send robot :slide-gripper :rarm
                (* (+ 45 40)
                   (cos (- pi/2 (deg2rad (abs (send robot :rarm :gripper-p :joint-angle))))))
                :relative nil)
          )
        )
      (send (send robot :rarm :end-coords) :dissoc object)
      (send *irtviewer* :draw-objects)
      )
    )
  )

(defun display-scraping-out-cyl
  (&key (yaw-angle 0) (object-size (list 40 80)) (robot *baxter*))
  (if (= (length object-size) 3)
    (unless (and (x-of-cube object)
                 (= (x-of-cube object) (elt object-size 0))
                 (= (y-of-cube object) (elt object-size 1))
                 (= (z-of-cube object) (elt object-size 2)))
      (make-bin-and-object :object-size object-size)
      )
    (unless (and (radius-of-cylinder object)
                 (= (radius-of-cylinder object) (elt object-size 0))
                 (= (height-of-cylinder object) (elt object-size 1)))
      (make-bin-and-object :object-size object-size)
      )
    )
  (locate-object :object-offset (float-vector 0
                                              (cond ((and (< yaw-angle (/ pi -4))
                                                          (> yaw-angle (/ (* pi 3) -4))) 70)
                                                    ((and (> yaw-angle (/ pi 4))
                                                          (< yaw-angle (/ (* pi 3) 4))) -70)
                                                    (t 0))
                                              -90)
                 :on-floor t)
  (setq target-coords (send object :copy-worldcoords))
  (when (height-of-cylinder object)
    (send target-coords :translate (float-vector 0 0 (/ (height-of-cylinder object) 2)) :local)
    )
  (send target-coords :rotate (- yaw-angle) :z :local)
  (send robot :rotate-gripper :rarm 0 :relative nil)
  (send robot :slide-gripper :rarm 124 :relative nil)
  (send robot :rarm :inverse-kinematics target-coords)
  (send robot :rarm :move-end-pos #f(-52 0 -20) :local)
  (send robot :hand-grasp-pose :rarm :cylindrical :angle 60)
  (send *irtviewer* :draw-objects)
  (unless (y-or-n-p "continue?") (return-from display-scraping-out-cyl))
  (send (send robot :rarm :end-coords) :assoc object)
  (send robot :rotate-gripper :rarm -45 :relative nil)
  (send robot :slide-gripper :rarm 100 :relative nil)
  (send (send robot :rarm :end-coords) :dissoc object)
  (send *irtviewer* :draw-objects)
  )

(defun display-scraping-out-cube
  (&key (yaw-angle 0) (object-size (list 80 80 80)) (robot *baxter*))
  (if (= (length object-size) 3)
    (unless (and (x-of-cube object)
                 (= (x-of-cube object) (elt object-size 0))
                 (= (y-of-cube object) (elt object-size 1))
                 (= (z-of-cube object) (elt object-size 2)))
      (make-bin-and-object :object-size object-size)
      )
    (unless (and (radius-of-cylinder object)
                 (= (radius-of-cylinder object) (elt object-size 0))
                 (= (height-of-cylinder object) (elt object-size 1)))
      (make-bin-and-object :object-size object-size)
      )
    )
  (locate-object :object-offset (float-vector 0
                                              (cond ((and (< yaw-angle (/ pi -4))
                                                          (> yaw-angle (/ (* pi 3) -4))) 70)
                                                    ((and (> yaw-angle (/ pi 4))
                                                          (< yaw-angle (/ (* pi 3) 4))) -70)
                                                    (t 0))
                                              -70)
                 :on-floor t)
  (setq target-coords (send object :copy-worldcoords))
  (when (height-of-cylinder object)
    (send target-coords :translate (float-vector 0 0 (/ (height-of-cylinder object) 2)) :local)
    )
  (send target-coords :rotate (- yaw-angle) :z :local)
  (send robot :rotate-gripper :rarm 0 :relative nil)
  (send robot :slide-gripper :rarm 124 :relative nil)
  (send robot :rarm :inverse-kinematics target-coords)
  (send robot :rarm :move-end-pos (float-vector (- -12 (/ (x-of-cube object) 2)) 0
                                                (- (/ (z-of-cube object) 2) 30)) :local)
  (send robot :hand-grasp-pre-pose :rarm :cylindrical)
  (send *irtviewer* :draw-objects)
  (unless (y-or-n-p "continue?") (return-from display-scraping-out-cube))
  (send (send robot :rarm :end-coords) :assoc object)
  (send robot :rotate-gripper :rarm -90 :relative nil)
  ;(send robot :slide-gripper :rarm 100 :relative nil)
  (send robot :hand-grasp-pose :rarm :cylindrical :angle 72)
  (send (send robot :rarm :end-coords) :dissoc object)
  (send *irtviewer* :draw-objects)
  )

(defun display-cyl-pinch
  (&key (object-size (list 140 70 70)) (robot *baxter*))
  (if (= (length object-size) 3)
    (unless (and (x-of-cube object)
                 (= (x-of-cube object) (elt object-size 0))
                 (= (y-of-cube object) (elt object-size 1))
                 (= (z-of-cube object) (elt object-size 2)))
      (make-bin-and-object :object-size object-size)
      )
    (unless (and (radius-of-cylinder object)
                 (= (radius-of-cylinder object) (elt object-size 0))
                 (= (height-of-cylinder object) (elt object-size 1)))
      (make-bin-and-object :object-size object-size)
      )
    )
  (locate-object :object-offset (float-vector 0 0 -70)
                 :on-floor t)
  (setq target-coords (send object :copy-worldcoords))
  (when (height-of-cylinder object)
    (send target-coords :translate (float-vector 0 0 (/ (height-of-cylinder object) 2)) :local)
    )
  (send target-coords :rotate pi/2 :z :local)
  (send robot :rotate-gripper :rarm 0 :relative nil)
  (send robot :slide-gripper :rarm 124 :relative nil)
  (send robot :rarm :inverse-kinematics target-coords :move-palm-end t)
  (send robot :rarm :move-end-pos (float-vector 15 0 100) :local)
  (send robot :hand-grasp-pose :rarm :cylindrical :angle 40)
  (send *irtviewer* :draw-objects)
  (unless (y-or-n-p "continue?") (return-from display-cyl-pinch))
  (send (send robot :rarm :palm-endpoint) :assoc object)
  (send robot :rotate-gripper :rarm -90 :relative nil)
  ;(send robot :slide-gripper :rarm 100 :relative nil)
  (send robot :hand-grasp-pose :rarm :cylindrical :angle 60)
  (send (send robot :rarm :palm-endpoint) :dissoc object)
  (send *irtviewer* :draw-objects)
  )

(defun display-placing
  (&key (style :suction) (aligned-with :z) (yaw-angle 0))
  (let (object-size rpy-coords coords-rpy)
    (cond ((eq style :suction)
           (cond ((eq aligned-with :z)
                  (setq object-size (list 80 80 80)))
                 ((eq aligned-with :y)
                  (setq object-size (list 80 240 40)))
                 )
           )
          ((eq style :opposed-pinch)
           (cond ((eq aligned-with :z)
                  (setq object-size (list 150 80 80)))
                 ((eq aligned-with :y)
                  (setq object-size (list 240 80 40)))
                 )
           )
          ((eq style :cylindrical-pinch)
           (cond ((eq aligned-with :z)
                  (setq object-size (list 80 80 40)))
                 ((eq aligned-with :y)
                  (setq object-size (list 60 240 40)))
                 )
           )
          )
    (unless (and (x-of-cube object)
                 (= (x-of-cube object) (elt object-size 0))
                 (= (y-of-cube object) (elt object-size 1))
                 (= (z-of-cube object) (elt object-size 2)))
      (make-bin-and-object :object-size object-size)
      )
    (send object :move-to (send *baxter* :rarm :end-coords :worldcoords) :world)
    (send object :translate (float-vector 0 0 (/ (z-of-cube object) -2)) :local)
    (send (send *baxter* :rarm :end-coords) :assoc object)
    (cond ((eq style :suction)
           (send *baxter* :hand-grasp-pre-pose :rarm :opposed)
           (cond ((eq aligned-with :z)
                  (send *baxter* :rotate-gripper :rarm 90 :relative nil)
                  (send *baxter* :slide-gripper :rarm 120 :relative nil)
                  (send *ti* :ik->bin-center :rarm *bin*
                        :offset #f(30 0 300)
                        :rotation-axis :z :use-gripper t
                        ;; to follow gravity
                        :parallel-with :world)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *baxter* :slide-gripper :rarm 120 :relative nil)
                  (send *ti* :ik->bin-center :rarm *bin*
                        :offset #f(30 0 -100)
                        :rotation-axis t :use-gripper t
                        ;; to follow gravity
                        :parallel-with :world)
                  (send *irtviewer* :draw-objects)
                  )
                 ((eq aligned-with :y)
                  (send *baxter* :slide-gripper :rarm 0 :relative nil)
                  (send *baxter* :rotate-gripper :rarm 30 :relative nil)
                  (send *ti* :ik->bin-center :rarm :l
                                    :offset #f(30 0 300)
                                    :rpy (float-vector pi/2 0 (/ pi -6))
                                    :rotation-axis t :use-gripper nil
                                    ;; to follow gravity
                                    :parallel-with :world)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *baxter* :slide-gripper :rarm 120 :relative nil)
                  (send *ti* :ik->bin-center :rarm :l
                                    :offset #f(30 0 -20)
                                    :rpy (float-vector pi/2 0 (/ pi -6))
                                    :rotation-axis t :use-gripper t
                                    ;; to follow gravity
                                    :parallel-with :world)
                  (send *irtviewer* :draw-objects)
                  )
                 )
           )
          ((eq style :opposed-pinch)
           (send *baxter* :hand-grasp-pose :rarm :opposed :angle 70)
           (send *baxter* :rotate-gripper :rarm 0 :relative nil)
           (send *baxter* :slide-gripper :rarm 0 :relative nil)
           (cond ((eq aligned-with :z)
                  (send *ti* :ik->bin-center :rarm :c
                        :offset #f(0 0 300)
                        :rpy (float-vector yaw-angle 0 0)
                        :rotation-axis t)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *ti* :ik->bin-center :rarm :c
                        :offset #f(0 0 0)
                        :rpy (float-vector yaw-angle 0 0)
                        :rotation-axis t)
                  (send *irtviewer* :draw-objects)
                  )
                 ((eq aligned-with :y)
                  (setq rpy-coords (make-coords :rpy (float-vector 0 (- pi/2 (/ pi 7)) 0)))
                  (send rpy-coords :rotate yaw-angle :z :local)
                  (setq coords-rpy (float-vector 0 0 0))
                  (dotimes (i (length (car (send rpy-coords :rpy-angle))))
                    (setf (aref coords-rpy i) (elt (car (send rpy-coords :rpy-angle)) i)))
                  (send *ti* :ik->bin-center :rarm :l
                        :offset #f(-30 0 300)
                        :rpy coords-rpy
                        :rotation-axis t)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *ti* :ik->bin-center :rarm :l
                        :offset #f(-20 0 -20)
                        :rpy coords-rpy
                        :rotation-axis t)
                  (send *irtviewer* :draw-objects)
                  )
                 )
           )
          ((eq style :cylindrical-pinch)
           (cond ((eq aligned-with :z)
                  (send *baxter* :hand-grasp-pose :rarm :cylindrical :angle 64)
                  (send *baxter* :rotate-gripper :rarm -90 :relative nil)
                  (send *baxter* :slide-gripper :rarm 90 :relative nil)
                  (send *ti* :ik->bin-center :rarm :c
                        :offset #f(0 0 300)
                        :rpy (float-vector yaw-angle 0 0)
                        :rotation-axis t :move-palm-end t)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *ti* :ik->bin-center :rarm :c
                        :offset #f(0 0 0)
                        :rpy (float-vector yaw-angle 0 0)
                        :rotation-axis t :move-palm-end t)
                  (send *irtviewer* :draw-objects)
                  )
                 ((eq aligned-with :y)
                  (send *baxter* :hand-grasp-pose :rarm :cylindrical :angle 90)
                  (send *baxter* :rotate-gripper :rarm -90 :relative nil)
                  (send *baxter* :slide-gripper :rarm (- (x-of-cube object) 6) :relative nil)
                  (send object :translate
                        (float-vector (+ (/ (x-of-cube object) 2) 15) 0 30) :local)
                  (setq rpy-coords (make-coords :rpy (float-vector 0 (- pi/2 (/ pi 6)) 0)))
                  (send rpy-coords :rotate yaw-angle :z :local)
                  (setq coords-rpy (float-vector 0 0 0))
                  (dotimes (i (length (car (send rpy-coords :rpy-angle))))
                    (setf (aref coords-rpy i) (elt (car (send rpy-coords :rpy-angle)) i)))
                  (send *ti* :ik->bin-center :rarm :l
                        :offset #f(15 0 300)
                        :rpy coords-rpy
                        :rotation-axis t :move-palm-end t)
                  (send *irtviewer* :draw-objects)
                  (unless (y-or-n-p "continue?") (return-from display-placing))
                  (send *ti* :ik->bin-center :rarm :l
                        :offset #f(15 0 0)
                        :rpy coords-rpy
                        :rotation-axis t :move-palm-end t)
                  (send *irtviewer* :draw-objects)
                  )
                 )
           )
          )
    (send (send *baxter* :rarm :end-coords) :dissoc object)
    )
  )
